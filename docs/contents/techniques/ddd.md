# 领域驱动设计

> 通过“战略设计”和“战术设计”的实践，对软件进行领域建模从而减少软件开发过程的复杂度。

## 分离领域

* 模式：Layered Architecture

用户界面层,应用层,领域层,基础设施层

* 模式：六边形架构（端口与适配器）
* 模式：面向服务架构
* 模式：CQRS(命令与查询分离职责分离)
* 模式：事件驱动架构

## 战术设计

### 软件中所表示的模型

* 模式：Entity实体(又称 Reference Object)

一些对象主要不是由它们的属性定义的，而是表示了一条标识线

* 莫斯Value Object值对象

用于描述领域的某个方面而本身没有标示的对象（用来描述事物的对象）

> 当我们只关心一个模型元素的属性时,应该是不可变的

* 模式： Service

某些情况下有些操作从概念上讲不属于任何对象

* 模式：Module(又称Package)

Module间应该是低耦合的，Module内应该是高内聚的

### 领域对象生命周期管理

* 模式：Aggregate

将Entity和Value Object分门别类的聚集到Aggregate中，并且定义Aggregate的边界。每一个Aggregate中选择一个Entity作为根，并通过根来控制边界内的其它所有对象的所有访问。只允许外部对象保持对根的引用。

* 模式：Factory

当创建一个对象或者创建Aggregate时，如果创建工作很复杂，或者暴露了过多的内部结构，则可以使用Factory进行封装

  1. 工厂方法(Factory Method)
  2. 抽象工厂(Abstract Factory)
  3. 构建器(Builder)

* 模式：Repository

## 战略设计

### 模式

* 模式： Bounded Context

明确定义模型所应用的上下文，根据团队的组织，软件系统的各个部分的用法以及物理表先（代码和数据库模式等）来设置模型的边界。在这些边界中严格保持模型的一致性，而不要受到边界外的问题的干扰和混淆。

* 模式：Continuous Integration

模型概念的集成以及实现的集成。建立一个把所有代码和其它实现共建频繁合并在一起的过程，并通过自动化测试来快速查明模型的分裂问题。严格坚持使用Ubiquitous Language，一遍再不同人的头脑中演变出不同的概念时，使所有人对模型能达成一个共识

* 模式：Context Map

识别项目中起作用的模型，并定义起Bounded context. 为每个BC命名，并把名称添加到Ubiquitous language中。 描述模型之间的联系点，明确所有通信需要的转换，并突出任何共享的内容。 先将当前情况描绘出来，以后再做改变。

### Bounded Context之间的关系

* 模式：Shared Kernel

通常是作为Core Domain或者一组Generic Submodule(通用子领域)。Share Kernel可以减少（非消除）重复，并且使两个子系统之间的集成变得相对容易一些。

* 模式：Custom/Supplier Development Team(客户/供应商)

XP极限编程：下游团队的代表类似于客户代表，参加上游团队的计划会议。两个团队共同开发自动化验收测试，用来验证预期的接口。 把这些测试添加到上游团队的测试套件中，一遍作为持续集成的一部分来运行。

实践：消费者驱动的契约测试

* 模式：Conformist（遵从）

严格遵从上游团队的模型，可以消除在Bounded Context之间进行转换的复杂性，景观这会限制下游设计人员的分割，而且可能不会得到理想的应用模型，但是选择conformity模式可以极大的简化集成。

当两个具有上游/下游关系的团队归不同的管理者指挥时，Custom/Supplier Team模式会失效。

* 模式：Anticorruption layer(防腐层)

创建一个隔离层，以便根据客户自己的领域模型来为客户提供相关的功能。这个层通过另外一个系统现有接口与其进行对话，而只需要对那个系统做出很少的修改，甚至无需修改。在内部，这个层在两个模型之间进行必要的双向转换。

实践：接口设配器模式

* 模式： Separate Way

集成总是代价高昂，而有时获得的收益却很小。在一个与其他上下文毫无关联的Bounded Context，使开发人员能够在一个小的范围内找到简单，专有的解决方案

* 模式：Open Host Service

当一个子系统必须与大量的其它系统进行集成时，为每一个集成指定一个转换层可能会减慢团队的工作速度。需要维护的东西越来越多，而且进行修改的时候单行的事情会越来越多。

定义一个协议，把你的子系统作为一组Service供其他系统访问。开放这个协议，一遍所有需要与你子系统集成的人可以使用它。当有新的集成需求时，就增强并扩展这个协议，但个别团队的特殊需求除外。瞒住这个特殊需求的方法是使用一次性的转换器来扩充协议，以便使共享协议简单且内聚。

* 模式：Published Language

Bounded Context之间的模型转换需要一种公共语言。
把一个具有良好文档化的，能够表达出所需领域信息的共享语言作为公共的通信媒介，必要时在其它信息与该语言之间进行转换。

实践：BDD

## 提炼领域模型

* 模式：Core Domain
* 模式：Generic Subdomain
* 模式： Domain Vision Statement

  写一份Core Domain的简短秒速（一页纸）以及它将会创造的价值，也就是“价值主张”。那些不能见你的领域模型与其他领域模型区分开的方面就不要写了。展示出领域模型是如何实现和均衡各方利益的。并根据新的理解随时修改它。

  实践： 电梯演讲

* 模式：Highlighted Core
* 模式：Cohesive Mechanism（内聚机制）
* 模式：Segregated Core
* 模式：Abstract Core

  把模型中最基本的概念识别出来，并分离到不同的类，抽象类，接口中。 设计这个抽象模型使之能够表达出重要组件之间的大部分交互。把这个完整的抽象模型放到它自己的Module中而专用，详细的实现类则留在由子域定义的Module中。